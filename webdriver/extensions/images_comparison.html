<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>appium.webdriver.extensions.images_comparison API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>appium.webdriver.extensions.images_comparison</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python

# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import Any, Dict, Union

from selenium import webdriver

from ..mobilecommand import MobileCommand as Command


class ImagesComparison(webdriver.Remote):

    def match_images_features(self, base64_image1: bytes, base64_image2: bytes, **opts: Any) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Performs images matching by features.

        Read
        https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html
        for more details on this topic.
        The method supports all image formats, which are supported by OpenCV itself.

        Args:
            base64_image1 (bytes): base64-encoded content of the first image
            base64_image2 (bytes): base64-encoded content of the second image

        Keyword Args:
            visualize (bool): Set it to True in order to return the visualization of the matching operation.
                matching visualization. False by default
            detectorName (str): One of possible feature detector names:
                &#39;AKAZE&#39;, &#39;AGAST&#39;, &#39;BRISK&#39;, &#39;FAST&#39;, &#39;GFTT&#39;, &#39;KAZE&#39;, &#39;MSER&#39;, &#39;SIFT&#39;, &#39;ORB&#39;
                Some of these detectors are not enabled in the default OpenCV deployment.
                &#39;ORB&#39; By default.
            matchFunc (str): One of supported matching functions names:
                &#39;FlannBased&#39;, &#39;BruteForce&#39;, &#39;BruteForceL1&#39;, &#39;BruteForceHamming&#39;,
                &#39;BruteForceHammingLut&#39;, &#39;BruteForceSL2&#39;
                &#39;BruteForce&#39; by default
            goodMatchesFactor (int): The maximum count of &#34;good&#34; matches (e. g. with minimal distances).
                This count is unlimited by default.

        Returns:
            The dictionary containing the following entries:

            visualization (bytes): base64-encoded content of PNG visualization of the current comparison
                operation. This entry is only present if `visualize` option is enabled
            count (int): The count of matched edges on both images.
                The more matching edges there are no both images the more similar they are.
            totalCount (int): The total count of matched edges on both images.
                It is equal to `count` if `goodMatchesFactor` does not limit the matches,
                otherwise it contains the total count of matches before `goodMatchesFactor` is
                applied.
            points1 (dict)): The array of matching points on the first image. Each point is a dictionary
                with &#39;x&#39; and &#39;y&#39; keys
            rect1 (dict): The bounding rect for the `points1` array or a zero rect if not enough matching points
                were found. The rect is represented by a dictionary with &#39;x&#39;, &#39;y&#39;, &#39;width&#39; and &#39;height&#39; keys
            points2 (dict): The array of matching points on the second image. Each point is a dictionary
                with &#39;x&#39; and &#39;y&#39; keys
            rect2 (dict): The bounding rect for the `points2` array or a zero rect if not enough matching points
                were found. The rect is represented by a dictionary with &#39;x&#39;, &#39;y&#39;, &#39;width&#39; and &#39;height&#39; keys
        &#34;&#34;&#34;
        options = {
            &#39;mode&#39;: &#39;matchFeatures&#39;,
            &#39;firstImage&#39;: base64_image1,
            &#39;secondImage&#39;: base64_image2,
            &#39;options&#39;: opts
        }
        return self.execute(Command.COMPARE_IMAGES, options)[&#39;value&#39;]

    def find_image_occurrence(self, base64_full_image: bytes, base64_partial_image: bytes,
                              **opts: Any) -&gt; Dict[str, Union[bytes, Dict]]:
        &#34;&#34;&#34;Performs images matching by template to find possible occurrence of the partial image
        in the full image.

        Read
        https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html
        for more details on this topic.
        The method supports all image formats, which are supported by OpenCV itself.

        Args:
            base64_full_image (bytes): base64-encoded content of the full image
            base64_partial_image (bytes): base64-encoded content of the partial image

        Keyword Args:
            visualize (bool): Set it to True in order to return the visualization of the matching operation.
                False by default

        Returns:
            The dictionary containing the following entries:
                visualization (bytes): base64-encoded content of PNG visualization of the current comparison
                    operation. This entry is only present if `visualize` option is enabled
                rect (dict): The region of the partial image occurrence on the full image.
                    The rect is represented by a dictionary with &#39;x&#39;, &#39;y&#39;, &#39;width&#39; and &#39;height&#39; keys
        &#34;&#34;&#34;
        options = {
            &#39;mode&#39;: &#39;matchTemplate&#39;,
            &#39;firstImage&#39;: base64_full_image,
            &#39;secondImage&#39;: base64_partial_image,
            &#39;options&#39;: opts
        }
        return self.execute(Command.COMPARE_IMAGES, options)[&#39;value&#39;]

    def get_images_similarity(self, base64_image1: bytes, base64_image2: bytes,
                              **opts: Any) -&gt; Dict[str, Union[bytes, Dict]]:
        &#34;&#34;&#34;Performs images matching to calculate the similarity score between them.

        The flow there is similar to the one used in
        `find_image_occurrence`, but it is mandatory that both images are of equal resolution.
        The method supports all image formats, which are supported by OpenCV itself.

        Args:
            base64_image1 (bytes): base64-encoded content of the first image
            base64_image2 (bytes): base64-encoded content of the second image

        Keyword Args:
            visualize (bool): Set it to True in order to return the visualization of the matching operation.
                False by default

        Returns:
            The dictionary containing the following entries:
                visualization (bytes): base64-encoded content of PNG visualization of the current comparison
                    operation. This entry is only present if `visualize` option is enabled
                score (float): The similarity score as a float number in range [0.0, 1.0].
                    1.0 is the highest score (means both images are totally equal).
        &#34;&#34;&#34;
        options = {
            &#39;mode&#39;: &#39;getSimilarity&#39;,
            &#39;firstImage&#39;: base64_image1,
            &#39;secondImage&#39;: base64_image2,
            &#39;options&#39;: opts
        }
        return self.execute(Command.COMPARE_IMAGES, options)[&#39;value&#39;]

    # pylint: disable=protected-access

    def _addCommands(self) -&gt; None:
        self.command_executor._commands[Command.COMPARE_IMAGES] = \
            (&#39;POST&#39;, &#39;/session/$sessionId/appium/compare_images&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="appium.webdriver.extensions.images_comparison.ImagesComparison"><code class="flex name class">
<span>class <span class="ident">ImagesComparison</span></span>
<span>(</span><span>command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None, options=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Controls a browser by sending commands to a remote server.
This server is expected to be running the WebDriver wire protocol
as defined at
<a href="https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol">https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol</a></p>
<p>:Attributes:
- session_id - String ID of the browser session started and controlled by this WebDriver.
- capabilities - Dictionaty of effective capabilities of this browser session as returned
by the remote server. See <a href="https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities">https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities</a>
- command_executor - remote_connection.RemoteConnection object used to execute commands.
- error_handler - errorhandler.ErrorHandler object used to handle errors.</p>
<p>Create a new driver that will issue commands using the wire protocol.</p>
<p>:Args:
- command_executor - Either a string representing URL of the remote server or a custom
remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
- desired_capabilities - A dictionary of capabilities to request when
starting the browser session. Required parameter.
- browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object.
Only used if Firefox is requested. Optional.
- proxy - A selenium.webdriver.common.proxy.Proxy object. The browser session will
be started with given proxy settings, if possible. Optional.
- keep_alive - Whether to configure remote_connection.RemoteConnection to use
HTTP keep-alive. Defaults to False.
- file_detector - Pass custom file detector object during instantiation. If None,
then default LocalFileDetector() will be used.
- options - instance of a driver options.Options class</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImagesComparison(webdriver.Remote):

    def match_images_features(self, base64_image1: bytes, base64_image2: bytes, **opts: Any) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Performs images matching by features.

        Read
        https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html
        for more details on this topic.
        The method supports all image formats, which are supported by OpenCV itself.

        Args:
            base64_image1 (bytes): base64-encoded content of the first image
            base64_image2 (bytes): base64-encoded content of the second image

        Keyword Args:
            visualize (bool): Set it to True in order to return the visualization of the matching operation.
                matching visualization. False by default
            detectorName (str): One of possible feature detector names:
                &#39;AKAZE&#39;, &#39;AGAST&#39;, &#39;BRISK&#39;, &#39;FAST&#39;, &#39;GFTT&#39;, &#39;KAZE&#39;, &#39;MSER&#39;, &#39;SIFT&#39;, &#39;ORB&#39;
                Some of these detectors are not enabled in the default OpenCV deployment.
                &#39;ORB&#39; By default.
            matchFunc (str): One of supported matching functions names:
                &#39;FlannBased&#39;, &#39;BruteForce&#39;, &#39;BruteForceL1&#39;, &#39;BruteForceHamming&#39;,
                &#39;BruteForceHammingLut&#39;, &#39;BruteForceSL2&#39;
                &#39;BruteForce&#39; by default
            goodMatchesFactor (int): The maximum count of &#34;good&#34; matches (e. g. with minimal distances).
                This count is unlimited by default.

        Returns:
            The dictionary containing the following entries:

            visualization (bytes): base64-encoded content of PNG visualization of the current comparison
                operation. This entry is only present if `visualize` option is enabled
            count (int): The count of matched edges on both images.
                The more matching edges there are no both images the more similar they are.
            totalCount (int): The total count of matched edges on both images.
                It is equal to `count` if `goodMatchesFactor` does not limit the matches,
                otherwise it contains the total count of matches before `goodMatchesFactor` is
                applied.
            points1 (dict)): The array of matching points on the first image. Each point is a dictionary
                with &#39;x&#39; and &#39;y&#39; keys
            rect1 (dict): The bounding rect for the `points1` array or a zero rect if not enough matching points
                were found. The rect is represented by a dictionary with &#39;x&#39;, &#39;y&#39;, &#39;width&#39; and &#39;height&#39; keys
            points2 (dict): The array of matching points on the second image. Each point is a dictionary
                with &#39;x&#39; and &#39;y&#39; keys
            rect2 (dict): The bounding rect for the `points2` array or a zero rect if not enough matching points
                were found. The rect is represented by a dictionary with &#39;x&#39;, &#39;y&#39;, &#39;width&#39; and &#39;height&#39; keys
        &#34;&#34;&#34;
        options = {
            &#39;mode&#39;: &#39;matchFeatures&#39;,
            &#39;firstImage&#39;: base64_image1,
            &#39;secondImage&#39;: base64_image2,
            &#39;options&#39;: opts
        }
        return self.execute(Command.COMPARE_IMAGES, options)[&#39;value&#39;]

    def find_image_occurrence(self, base64_full_image: bytes, base64_partial_image: bytes,
                              **opts: Any) -&gt; Dict[str, Union[bytes, Dict]]:
        &#34;&#34;&#34;Performs images matching by template to find possible occurrence of the partial image
        in the full image.

        Read
        https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html
        for more details on this topic.
        The method supports all image formats, which are supported by OpenCV itself.

        Args:
            base64_full_image (bytes): base64-encoded content of the full image
            base64_partial_image (bytes): base64-encoded content of the partial image

        Keyword Args:
            visualize (bool): Set it to True in order to return the visualization of the matching operation.
                False by default

        Returns:
            The dictionary containing the following entries:
                visualization (bytes): base64-encoded content of PNG visualization of the current comparison
                    operation. This entry is only present if `visualize` option is enabled
                rect (dict): The region of the partial image occurrence on the full image.
                    The rect is represented by a dictionary with &#39;x&#39;, &#39;y&#39;, &#39;width&#39; and &#39;height&#39; keys
        &#34;&#34;&#34;
        options = {
            &#39;mode&#39;: &#39;matchTemplate&#39;,
            &#39;firstImage&#39;: base64_full_image,
            &#39;secondImage&#39;: base64_partial_image,
            &#39;options&#39;: opts
        }
        return self.execute(Command.COMPARE_IMAGES, options)[&#39;value&#39;]

    def get_images_similarity(self, base64_image1: bytes, base64_image2: bytes,
                              **opts: Any) -&gt; Dict[str, Union[bytes, Dict]]:
        &#34;&#34;&#34;Performs images matching to calculate the similarity score between them.

        The flow there is similar to the one used in
        `find_image_occurrence`, but it is mandatory that both images are of equal resolution.
        The method supports all image formats, which are supported by OpenCV itself.

        Args:
            base64_image1 (bytes): base64-encoded content of the first image
            base64_image2 (bytes): base64-encoded content of the second image

        Keyword Args:
            visualize (bool): Set it to True in order to return the visualization of the matching operation.
                False by default

        Returns:
            The dictionary containing the following entries:
                visualization (bytes): base64-encoded content of PNG visualization of the current comparison
                    operation. This entry is only present if `visualize` option is enabled
                score (float): The similarity score as a float number in range [0.0, 1.0].
                    1.0 is the highest score (means both images are totally equal).
        &#34;&#34;&#34;
        options = {
            &#39;mode&#39;: &#39;getSimilarity&#39;,
            &#39;firstImage&#39;: base64_image1,
            &#39;secondImage&#39;: base64_image2,
            &#39;options&#39;: opts
        }
        return self.execute(Command.COMPARE_IMAGES, options)[&#39;value&#39;]

    # pylint: disable=protected-access

    def _addCommands(self) -&gt; None:
        self.command_executor._commands[Command.COMPARE_IMAGES] = \
            (&#39;POST&#39;, &#39;/session/$sessionId/appium/compare_images&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>selenium.webdriver.remote.webdriver.WebDriver</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="appium.webdriver.webdriver.WebDriver" href="../webdriver.html#appium.webdriver.webdriver.WebDriver">WebDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="appium.webdriver.extensions.images_comparison.ImagesComparison.find_image_occurrence"><code class="name flex">
<span>def <span class="ident">find_image_occurrence</span></span>(<span>self, base64_full_image, base64_partial_image, **opts)</span>
</code></dt>
<dd>
<section class="desc"><p>Performs images matching by template to find possible occurrence of the partial image
in the full image.</p>
<p>Read
<a href="https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html">https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html</a>
for more details on this topic.
The method supports all image formats, which are supported by OpenCV itself.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base64_full_image</code></strong> :&ensp;<code>bytes</code></dt>
<dd>base64-encoded content of the full image</dd>
<dt><strong><code>base64_partial_image</code></strong> :&ensp;<code>bytes</code></dt>
<dd>base64-encoded content of the partial image</dd>
</dl>
<p>Keyword Args:
visualize (bool): Set it to True in order to return the visualization of the matching operation.
False by default</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>dictionary</code> <code>containing</code> <code>the</code> <code>following</code> <code>entries</code>:</dt>
<dd>visualization (bytes): base64-encoded content of PNG visualization of the current comparison
operation. This entry is only present if <code>visualize</code> option is enabled
rect (dict): The region of the partial image occurrence on the full image.
The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_image_occurrence(self, base64_full_image: bytes, base64_partial_image: bytes,
                          **opts: Any) -&gt; Dict[str, Union[bytes, Dict]]:
    &#34;&#34;&#34;Performs images matching by template to find possible occurrence of the partial image
    in the full image.

    Read
    https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html
    for more details on this topic.
    The method supports all image formats, which are supported by OpenCV itself.

    Args:
        base64_full_image (bytes): base64-encoded content of the full image
        base64_partial_image (bytes): base64-encoded content of the partial image

    Keyword Args:
        visualize (bool): Set it to True in order to return the visualization of the matching operation.
            False by default

    Returns:
        The dictionary containing the following entries:
            visualization (bytes): base64-encoded content of PNG visualization of the current comparison
                operation. This entry is only present if `visualize` option is enabled
            rect (dict): The region of the partial image occurrence on the full image.
                The rect is represented by a dictionary with &#39;x&#39;, &#39;y&#39;, &#39;width&#39; and &#39;height&#39; keys
    &#34;&#34;&#34;
    options = {
        &#39;mode&#39;: &#39;matchTemplate&#39;,
        &#39;firstImage&#39;: base64_full_image,
        &#39;secondImage&#39;: base64_partial_image,
        &#39;options&#39;: opts
    }
    return self.execute(Command.COMPARE_IMAGES, options)[&#39;value&#39;]</code></pre>
</details>
</dd>
<dt id="appium.webdriver.extensions.images_comparison.ImagesComparison.get_images_similarity"><code class="name flex">
<span>def <span class="ident">get_images_similarity</span></span>(<span>self, base64_image1, base64_image2, **opts)</span>
</code></dt>
<dd>
<section class="desc"><p>Performs images matching to calculate the similarity score between them.</p>
<p>The flow there is similar to the one used in
<code>find_image_occurrence</code>, but it is mandatory that both images are of equal resolution.
The method supports all image formats, which are supported by OpenCV itself.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base64_image1</code></strong> :&ensp;<code>bytes</code></dt>
<dd>base64-encoded content of the first image</dd>
<dt><strong><code>base64_image2</code></strong> :&ensp;<code>bytes</code></dt>
<dd>base64-encoded content of the second image</dd>
</dl>
<p>Keyword Args:
visualize (bool): Set it to True in order to return the visualization of the matching operation.
False by default</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>dictionary</code> <code>containing</code> <code>the</code> <code>following</code> <code>entries</code>:</dt>
<dd>visualization (bytes): base64-encoded content of PNG visualization of the current comparison
operation. This entry is only present if <code>visualize</code> option is enabled
score (float): The similarity score as a float number in range [0.0, 1.0].
1.0 is the highest score (means both images are totally equal).</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_images_similarity(self, base64_image1: bytes, base64_image2: bytes,
                          **opts: Any) -&gt; Dict[str, Union[bytes, Dict]]:
    &#34;&#34;&#34;Performs images matching to calculate the similarity score between them.

    The flow there is similar to the one used in
    `find_image_occurrence`, but it is mandatory that both images are of equal resolution.
    The method supports all image formats, which are supported by OpenCV itself.

    Args:
        base64_image1 (bytes): base64-encoded content of the first image
        base64_image2 (bytes): base64-encoded content of the second image

    Keyword Args:
        visualize (bool): Set it to True in order to return the visualization of the matching operation.
            False by default

    Returns:
        The dictionary containing the following entries:
            visualization (bytes): base64-encoded content of PNG visualization of the current comparison
                operation. This entry is only present if `visualize` option is enabled
            score (float): The similarity score as a float number in range [0.0, 1.0].
                1.0 is the highest score (means both images are totally equal).
    &#34;&#34;&#34;
    options = {
        &#39;mode&#39;: &#39;getSimilarity&#39;,
        &#39;firstImage&#39;: base64_image1,
        &#39;secondImage&#39;: base64_image2,
        &#39;options&#39;: opts
    }
    return self.execute(Command.COMPARE_IMAGES, options)[&#39;value&#39;]</code></pre>
</details>
</dd>
<dt id="appium.webdriver.extensions.images_comparison.ImagesComparison.match_images_features"><code class="name flex">
<span>def <span class="ident">match_images_features</span></span>(<span>self, base64_image1, base64_image2, **opts)</span>
</code></dt>
<dd>
<section class="desc"><p>Performs images matching by features.</p>
<p>Read
<a href="https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html">https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html</a>
for more details on this topic.
The method supports all image formats, which are supported by OpenCV itself.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base64_image1</code></strong> :&ensp;<code>bytes</code></dt>
<dd>base64-encoded content of the first image</dd>
<dt><strong><code>base64_image2</code></strong> :&ensp;<code>bytes</code></dt>
<dd>base64-encoded content of the second image</dd>
</dl>
<p>Keyword Args:
visualize (bool): Set it to True in order to return the visualization of the matching operation.
matching visualization. False by default
detectorName (str): One of possible feature detector names:
'AKAZE', 'AGAST', 'BRISK', 'FAST', 'GFTT', 'KAZE', 'MSER', 'SIFT', 'ORB'
Some of these detectors are not enabled in the default OpenCV deployment.
'ORB' By default.
matchFunc (str): One of supported matching functions names:
'FlannBased', 'BruteForce', 'BruteForceL1', 'BruteForceHamming',
'BruteForceHammingLut', 'BruteForceSL2'
'BruteForce' by default
goodMatchesFactor (int): The maximum count of "good" matches (e. g. with minimal distances).
This count is unlimited by default.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>dictionary</code> <code>containing</code> <code>the</code> <code>following</code> <code>entries</code>:</dt>
<dd>&nbsp;</dd>
<dt><strong><code>visualization</code></strong> :&ensp;<code>bytes</code></dt>
<dd>base64-encoded content of PNG visualization of the current comparison
operation. This entry is only present if <code>visualize</code> option is enabled</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code></dt>
<dd>The count of matched edges on both images.
The more matching edges there are no both images the more similar they are.</dd>
<dt><strong><code>totalCount</code></strong> :&ensp;<code>int</code></dt>
<dd>The total count of matched edges on both images.
It is equal to <code>count</code> if <code>goodMatchesFactor</code> does not limit the matches,
otherwise it contains the total count of matches before <code>goodMatchesFactor</code> is
applied.</dd>
<dt><code>points1</code> (<code>dict</code>)): <code>The</code> <code>array</code> of <code>matching</code> <code>points</code> <code>on</code> <code>the</code> <code>first</code> <code>image.</code> <code>Each</code> <code>point</code> <code>is</code> <code>a</code> <code>dictionary</code></dt>
<dd>with 'x' and 'y' keys</dd>
<dt><strong><code>rect1</code></strong> :&ensp;<code>dict</code></dt>
<dd>The bounding rect for the <code>points1</code> array or a zero rect if not enough matching points
were found. The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys</dd>
<dt><strong><code>points2</code></strong> :&ensp;<code>dict</code></dt>
<dd>The array of matching points on the second image. Each point is a dictionary
with 'x' and 'y' keys</dd>
<dt><strong><code>rect2</code></strong> :&ensp;<code>dict</code></dt>
<dd>The bounding rect for the <code>points2</code> array or a zero rect if not enough matching points
were found. The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_images_features(self, base64_image1: bytes, base64_image2: bytes, **opts: Any) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Performs images matching by features.

    Read
    https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html
    for more details on this topic.
    The method supports all image formats, which are supported by OpenCV itself.

    Args:
        base64_image1 (bytes): base64-encoded content of the first image
        base64_image2 (bytes): base64-encoded content of the second image

    Keyword Args:
        visualize (bool): Set it to True in order to return the visualization of the matching operation.
            matching visualization. False by default
        detectorName (str): One of possible feature detector names:
            &#39;AKAZE&#39;, &#39;AGAST&#39;, &#39;BRISK&#39;, &#39;FAST&#39;, &#39;GFTT&#39;, &#39;KAZE&#39;, &#39;MSER&#39;, &#39;SIFT&#39;, &#39;ORB&#39;
            Some of these detectors are not enabled in the default OpenCV deployment.
            &#39;ORB&#39; By default.
        matchFunc (str): One of supported matching functions names:
            &#39;FlannBased&#39;, &#39;BruteForce&#39;, &#39;BruteForceL1&#39;, &#39;BruteForceHamming&#39;,
            &#39;BruteForceHammingLut&#39;, &#39;BruteForceSL2&#39;
            &#39;BruteForce&#39; by default
        goodMatchesFactor (int): The maximum count of &#34;good&#34; matches (e. g. with minimal distances).
            This count is unlimited by default.

    Returns:
        The dictionary containing the following entries:

        visualization (bytes): base64-encoded content of PNG visualization of the current comparison
            operation. This entry is only present if `visualize` option is enabled
        count (int): The count of matched edges on both images.
            The more matching edges there are no both images the more similar they are.
        totalCount (int): The total count of matched edges on both images.
            It is equal to `count` if `goodMatchesFactor` does not limit the matches,
            otherwise it contains the total count of matches before `goodMatchesFactor` is
            applied.
        points1 (dict)): The array of matching points on the first image. Each point is a dictionary
            with &#39;x&#39; and &#39;y&#39; keys
        rect1 (dict): The bounding rect for the `points1` array or a zero rect if not enough matching points
            were found. The rect is represented by a dictionary with &#39;x&#39;, &#39;y&#39;, &#39;width&#39; and &#39;height&#39; keys
        points2 (dict): The array of matching points on the second image. Each point is a dictionary
            with &#39;x&#39; and &#39;y&#39; keys
        rect2 (dict): The bounding rect for the `points2` array or a zero rect if not enough matching points
            were found. The rect is represented by a dictionary with &#39;x&#39;, &#39;y&#39;, &#39;width&#39; and &#39;height&#39; keys
    &#34;&#34;&#34;
    options = {
        &#39;mode&#39;: &#39;matchFeatures&#39;,
        &#39;firstImage&#39;: base64_image1,
        &#39;secondImage&#39;: base64_image2,
        &#39;options&#39;: opts
    }
    return self.execute(Command.COMPARE_IMAGES, options)[&#39;value&#39;]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="appium.webdriver.extensions" href="index.html">appium.webdriver.extensions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="appium.webdriver.extensions.images_comparison.ImagesComparison" href="#appium.webdriver.extensions.images_comparison.ImagesComparison">ImagesComparison</a></code></h4>
<ul class="">
<li><code><a title="appium.webdriver.extensions.images_comparison.ImagesComparison.find_image_occurrence" href="#appium.webdriver.extensions.images_comparison.ImagesComparison.find_image_occurrence">find_image_occurrence</a></code></li>
<li><code><a title="appium.webdriver.extensions.images_comparison.ImagesComparison.get_images_similarity" href="#appium.webdriver.extensions.images_comparison.ImagesComparison.get_images_similarity">get_images_similarity</a></code></li>
<li><code><a title="appium.webdriver.extensions.images_comparison.ImagesComparison.match_images_features" href="#appium.webdriver.extensions.images_comparison.ImagesComparison.match_images_features">match_images_features</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>